
**Очередь** - это линейная структура данных организованная по принципу **FIFO**(First in first out), может быть реализована на основе односвязного списка или одномерного массива.

Очередь обладает указателями *start* и *end*, ссылающиеся на первый и последний элементы соответственно.

Реализации очереди на базе одномерного массива:
1. Преимущества:
	- Проще в разработке в сравнении с версией на связном списке.
	- Экономия памяти в сравнении с версией на связном списке.
	- Целостность памяти позволяет быстрее выполнять операции.
2. Недостатки:
	- Размер очереди ограничен размером массива, добавление сверх размерности повлечет за собйо переопределение структуры и как следствие скорость операций снизится до $O(n)$.

> В данной реализации операции *enqueue* и *dequeue* не будут удалять или добавлять новые элементы, они будут переопределять уже существующие ячейки и указатели, в таком случае сложность их будет $O(1)$, в противном случае $O(n)$.

Реализация очереди на базе односвязного списка:
1. Преимущества:
	- Размер стека ограничивается только памтью.
2. Недостатки:
	- Очередь будет затрачивать дополнительную память на хранение ссылок.
	- Данная версия так же сложнее в разработке.
	- Из-за фрагментированости используемой памяти, работает медленнее чем версия на базе одномерног омассива.

>В данной реализации операции *enqueue* и *dequeue* будут выполняться за $O(1)$.

---
#### Базовые методы:
---
- Enqueue(X) - добавляет элемент в конец очереди.
- Dequeue() - возвращает первый элемент в очереди, удаляя его из структуры.
- isEmpty() - проверяет наличие элементов в очереди.
- size - свойство хранящее текущий размер очереди.

![[queue.png]]



---
### Очередь на связном списке:
---
```ts
class Node<T> {
    constructor(
        public data: T,
        public next: ListNode<T> | null = null,
        public prev: ListNode<T> | null = null
    ){}
}



class Queue<T> {
    constructor(
        public head: ListNode<T> | null = null,
        public tail: ListNode<T> | null = null,
        public size: number = 0
    ){}
    
    dequeue(): T|null { // O(1)
		if ( this.head ) {
			const res = this.head.data
			this.head = this.head.next
			if ( this.head )
				this.head.prev = null
			--this.size
			return res
		} else {
			return null
		}
    }
    
    enqueue(data: T): Queue<T> { // O(1)
        let newNode = new ListNode(data)
        if (this.head && this.tail) {
            this.tail.next = newNode
            newNode.prev = this.tail
        } else {
            this.head = newNode
        }
        this.tail = newNode
        ++this.size
        return this
    }

	 isEmpty(): boolean {
        return this.size === 0
    }
}
```



---
#### Очередь на массиве:
---
```ts
class Queue<T> {
	private container: Array<T|null>
	private head: number = 0
	private tail: number = 0
	private curr: number = 0

	constructor(private readonly size: number){
		this.container = Array(size < 0 ? 0 : size)
	}

	dequeue(): T|null { // O(1)
		if ( !this.isEmpty() ) {
			--this.curr
			this.head = this.head % this.size
			const res = this.container[this.head]
			this.container[this.head++] = null
			return res
		} else {
			return null
		}
	}

	enqueue(data: T): Queue<T> { // O(1)
		if ( this.curr < this.size ) {
			++this.curr
			this.tail = this.tail % this.size
			this.container[this.tail++] = data
		}
		return this
		
	}

	peak(): T|null {
		return this.container[this.head] || null
	}

	isEmpty(): boolean {
		return this.size === 0
	}
}
```


