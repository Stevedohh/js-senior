
**Устойчивая сортировка** - сортировка, которая не меняет относительный порядок сортируемых элементов, имеющих одинаковые ключи, по которым происходит сортировка.

| Название                                | Время исполнения                  | Затраты памяти | Примечание                             |
| --------------------------------------- | --------------------------------- | -------------- | -------------------------------------- |
| Сортировка пузырьком *(Bubble sort)*    | от $O(n^2)$ до $O(n^2)$           | $O(1)$         |                                        |
| Сортировка вставками *(Insertion sort)* | от $O(n^2)$ до $O(n^2)$           | $O(1)$         |                                        |
| Сортировка слиянием *(Merge sort)*      | от $O(n \log n)$ до $O(n \log n)$ | $O(n)$         |                                        |
| Гибридная сортировка *(Timsort)*        | от $O(n \log n)$ до $O(n \log n)$ | O(1)           | Гибрид сортировок вставками и слиянием |
| Быстрая сортировка Хоара (Quick sort) | от $O(n^2)$ до $O(n \log n)$ |                |                                        |
| Сортировка с помощью двоичного дерева *(Tree sort)* | от $O(n^2)$ до $O(n \log n)$ | $O(n)$ |




---
#### Сортировка пузырьком
---
> Этот 

```js
let a = [4,7,5,9,2,1,3,6,9,0,3,5,4]

function bubbleSort(arr) {
    for ( let i = 0; i < arr.length-1; ++i )
        for ( let j = 0; j < arr.length-i-1; ++j )
            if ( arr[j] > arr[j+1] )
                [ arr[j], arr[j+1] ] = [ arr[j+1], arr[j] ]
}

bubbleSort(a) // [0,1,2,3,3,4,4,5,5,6,7,9,9]
```



---
#### Сортировка вставками
---
> Это алгоритм в котором элементы входной последовательности просматриваются по одному, и каждый новый поступивший элемент размещается в подходящее место среди ранее упорядоченных элементов.

```js
let a = [4,7,5,9,2,1,3,6,9,0,3,5,4]

function insertionSort(arr) { 
    for ( let i = 1; i < arr.length; ++i ) { 
        let key = arr[i], 
            j = i - 1
			
        while ( j >= 0 && arr[j] > key )
            arr[j + 1] = arr[j--]
            
        arr[j + 1] = key;
    } 
}

insertionSort(a) // [0,1,2,3,3,4,4,5,5,6,7,9,9]
```



---
#### Сортировка слиянием
---
> Этот алгоритм похож на [быструю сортировку], только без опорных элементов.

Разбиваем массив на две части. Затем сортируем каждую отдельно и соединяем два отсортированных массива в один. Условие остановки рекурсии — сортировка массива из одного или нуля элементов. Худший кейс $О(n∗log(n))$.

```js
let a = [4,7,5,9,2,1,3,6,9,0,3,5,4]

function merge(arr, l, m, r)
{
    let [L,R] = [ Array(m - l + 1), Array(r - m) ]
 
    for (let i = 0; i < L.length;)
        L[i] = arr[l + i++]
        
    for (let j = 0; j < R.length;)
        R[j] = arr[m + 1 + j++]

    let [i,j,k] = [0,0,l]
 
    while (i < L.length && j < R.length)
        arr[k++] = R[j] > L[i] ? L[i++] : R[j++]

    while (i < L.length)
        arr[k++] = L[i++]
    
    while (j < R.length)
        arr[k++] = R[j++]
}

function mergeSort(arr, l=0, r=arr.length-1){
    if (l >= r) return null
    let m = l + (r-l) / 2 | 0
    mergeSort(arr,l,m)
    mergeSort(arr,m+1,r)
    merge(arr,l,m,r)
}

mergeSort(a) // [0,1,2,3,3,4,4,5,5,6,7,9,9]
```

Шаги сортировки слиянием `merge(arr, l, r, buffer)`:
1.  Принимаем на вход массив `arr` и индексы начала и конца участка `start` и `end`, который нужно отсортировать. При первом запуске они будут `0` и `arr.length - 1`. Массив-буфер `buffer` по умолчанию не определён.
2.  Если `end ≤ start`, выходим из алгоритма и возвращаем входной массив. Сортировать нечего.
3.  Если буфер не определён, создадим его копией входного массива. Это потребуется только на первом вызове.
4.  Определяем середину массива: `mid = Math.floor((start + end) / 2);`.
5.  Вызываем сортировку левого и правого участков массива: `mergeSort(arr, start, mid, buffer)` и `mergeSort(arr, mid + 1, end, buffer)`.
6.  Совмещаем результаты отсортированных правой и левой частей:
    -   Копируем значения из `arr` на отрезке от `start` до `end` в `buffer`. Сделав массив `buffer` в самом начале сортировки, мы сэкономили память. В противном случае, чтобы совместить два результата, на каждом шаге потребовалось бы создать две дополнительные копии `arr` на участках от `start` до `mid` и от `mid+1` до `end`.
    -   Создаём: две переменные, чтобы отследить индексом левую и правую части — `l = start` и `r = mid + 1`; переменную, чтобы отследить текущую позицию — `i = start`.
    -   Пока `l < mid + 1` и `r < end + 1`, сравниваем значения `buffer[l]` и `buffer[r]`.
    -   Если `buffer[l] <= buffer[r]`, присваиваем `arr[i]` значение `buffer[l]`, инкрементируем `l` и `i`.
    -   В противном случае присваиваем `arr[i]` значение `buffer[r]`, инкрементируем `r` и `i`.
    -   Пока `l < mid + 1`, присваиваем `arr[i]` значение `buffer[l]`, инкрементируем `l` и `i`.
    -   Пока `r < end + 1`, присваиваем `arr[i]` значение `buffer[r]`, инкрементируем `r` и `i`.
7.  Возвращаем отсортированный массив `arr`.



---
#### Быстрая сортировка
---
> Этот алгоритм относится к подъоду "разделяй и властвуй". Худший кейс $O(n2)$

```js
let a = [4,7,5,9,2,1,3,6,9,0,3,5,4]

function partition(arr, l, r) {
    let pivot = arr[r],
        i = (l - 1)

    for (let j = l; j < r; j++)
        if (arr[j] < pivot)
            (++i,[ arr[i], arr[j] ] = [ arr[j], arr[i] ])
    
    ;[ arr[i+1], arr[r] ] = [ arr[r], arr[i+1] ]
    
    return i + 1
}
  
function quickSort(arr, l=0, r=arr.length-1) {
    if (l < r) {
        let pi = partition(arr, l, r)
        quickSort(arr, l, pi - 1)
        quickSort(arr, pi + 1, r)
    }
}

quickSort(a) // [0,1,2,3,3,4,4,5,5,6,7,9,9]
```

Шаги быстрой сортировки `quick(arr, l, r)`:
1. Принимаем на вход массив `arr` и индексы начала и конца участка `start` и `end`, который нужно отсортировать.
2. Если `r ≤ l`, выходим из алгоритма и возвращаем входной массив. Сортировать нечего.
3. Нужно выбрать опорный элемент и переставить элементы в массиве. Элементы, меньшие или равные опорному, окажутся слева, большие — справа.
	1. Выбираем опорный элемент как последний элемент на участке `pivot = arr[r]`. Выставляем `i = l`.
	2. В цикле от `l` до `r`, где текущий индекс будет `j`, сравниваем `arr[j]` с `pivot`
	3. Если `arr[j] < pivot`, меняем местами значения с индексами `j` и `i`, увеличиваем `i` на единицу
	4. После окончания цикла меняем местами значения в `i` и `end`, возвращаем `i`
4. Запускаем алгоритм отдельно на левой и правой частях как `quick(arr,l,i-1)` и `quick(arr,i+1,r)`. 




