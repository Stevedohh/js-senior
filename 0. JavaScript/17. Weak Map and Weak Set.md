
### Weak Map
---

Первое его отличие от `Map` в том, что ключи в `WeakMap` должны быть объектами, а не примитивными значениями:

Как работает `Map`

```js
let john = { name: "John" }; 

let map = new Map(); 
map.set(john, "..."); 

john = null; 

// перезаписываем ссылку на объект 
// объект john сохранён внутри объекта `Map`, он доступен через map.keys()
```

Как работает `WeakMap`

если мы используем объект в качестве ключа и если больше нет ссылок на этот объект, то он будет удалён из памяти **(и из объекта `WeakMap`)** автоматически.

```js
let john = { name: "John" }; 

let weakMap = new WeakMap(); 
weakMap.set(john, "..."); 

john = null; 

// перезаписываем ссылку на объект 
// объект john удалён из памяти!
```

`WeakMap` не поддерживает перебор и методы `keys()`, `values()`, `entries()`, так что нет способа взять все ключи или значения из неё.

В `WeakMap` присутствуют только следующие методы:

-   `weakMap.get(key)`
-   `weakMap.set(key, value)`
-   `weakMap.delete(key)`
-   `weakMap.has(key)`

---
### Но нахуя оно нам надо?
---

Если мы работаем с объектом, который «принадлежит» другому коду, может быть даже сторонней библиотеке, и хотим сохранить у себя какие-то данные для него, которые должны существовать лишь пока существует этот объект, то `WeakMap` – как раз то, что нужно.

Мы кладём эти данные в `WeakMap`, используя объект как ключ, и когда сборщик мусора удалит объекты из памяти, ассоциированные с ними данные тоже автоматически исчезнут.

```js
weakMap.set(john, "секретные документы"); 
// если john умрёт, "секретные документы" будут автоматически уничтожены
```


#### Пример с пользователями и колличеством посещений

Предположим, у нас есть код, который ведёт учёт посещений для пользователей. Информация хранится в коллекции `Map`: объект, представляющий пользователя, является ключом, а количество визитов – значением. Когда пользователь нас покидает (его объект удаляется сборщиком мусора), то больше нет смысла хранить соответствующий счётчик посещений.

#### Пример с кешированием

Если мы будем использовать `WeakMap` вместо `Map`, то эта проблема исчезнет: закешированные результаты будут автоматически удалены из памяти сборщиком мусора.

```js
// 📁 cache.js
let cache = new WeakMap();

// вычисляем и запоминаем результат
function process(obj) {
  if (!cache.has(obj)) {
    let result = /* вычисляем результат для объекта */ obj;
    cache.set(obj, result);
  } 

  return cache.get(obj);
}
  

// 📁 main.js
let obj = {/* какой-то объект */};

let result1 = process(obj);
let result2 = process(obj);

// ...позже, когда объект больше не нужен:
obj = null;

// Нет возможности получить cache.size, так как это WeakMap,
// но он равен 0 или скоро будет равен 0
// Когда сборщик мусора удаляет obj, связанные с ним данные из кеша тоже удаляются
```

---
### Weak Map
---

Коллекция `WeakSet` ведёт себя похоже:

-   Она аналогична `Set`, но мы можем добавлять в `WeakSet` только объекты (не примитивные значения).
-   Объект присутствует в множестве только до тех пор, пока доступен где-то ещё.
-   Как и `Set`, она поддерживает `add`, `has` и `delete`, но не `size`, `keys()` и не является перебираемой.

---
### Итого
---

`WeakMap` – это `Map`-подобная коллекция, позволяющая использовать в качестве ключей только объекты, и автоматически удаляющая их вместе с соответствующими значениями, как только они становятся недостижимыми иными путями.

`WeakSet` – это `Set`-подобная коллекция, которая хранит только объекты и удаляет их, как только они становятся недостижимыми иными путями.

Обе этих структуры данных не поддерживают методы и свойства, работающие со всем содержимым сразу или возвращающие информацию о размере коллекции. Возможны только операции на отдельном элементе коллекции.

`WeakMap` и `WeakSet` используются как вспомогательные структуры данных в дополнение к «основному» месту хранения объекта. Если объект удаляется из основного хранилища и нигде не используется, кроме как в качестве ключа в `WeakMap` или в `WeakSet`, то он будет удалён автоматически.