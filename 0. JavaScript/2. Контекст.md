
> Обращение к текущему контексту выполнения происходит при помощи инструкции **this**.

---
#### Контекст по умолчанию:
---
> Данный вид контекста присваивается всем функциям в глобальной области видимости, его значение зависит от места исполнения кода и строгого режима.

- В браузере контекстом по умолчанию является объект `window`.
- В **NodeJS** контекстом по умолчанию является объект `global`.
- При работе в строгом режиме, контекст по умолчанию - `undefined`.



---
#### Присвоенный контекст:
---
> Данный вид контекста присваивается при помощи одного из трех методов функций:

1. `f.call(контекст, аргмуенты...)` - Вызывает функцию с указаннм контекстом и множеством аргументов.
2. `f.apply(контекст, \[аргументы...\])` - Вызывает функцию с указаннм контекстом и массивом аргументов.
3. `f.bind(контекст, аргмуенты...)` - Данный метод создает новую "привязанную функцию", в отличии от call и apply, требует дополнительный вызов.



---
#### Контекст объекта:
---
> Контекст может быть определен вызовом функции, как метода объекта.

```js
const obj = {
	text: "some text",
	method: function(){
		console.log(this.text)
	}
}

obj.method() // some text

const newMethod = obj.method

newMethod() // undefined
```

> При сохранении ссылки на метод использующий контекст своего объекта и последующем отдельном от объекта вызове этого метода, произойдет потеря контекста метода.



---
#### Контекст конструктора:
---
> Контекст функции конструктора определяется использованием оператора **new** при вызове функции.

```js
function Human(name, age){
	this.name = name
	this.age = age
}
console.log( new Human("Daniil", 22) ) // Human { name: 'Daniil', age: 22 }
```



---
#### Контекст стрелочных функций:
---
> Контекст стрелочных функций определяется не во время вызова, а во время объявления. Так же у стрелочных функций нет собственного контекста, их контекст определяется внешней областью видимости.

```js
const obj = { 
	text: "some text",
	method: () => {
		console.log(this.text)
	} 
}; 

obj.method() // undefined
```

> Стрелочные функции не имеет смысла использовать в качестве методов объекта, это приведет к потере контекста.

Но иногда использование стрелочных функций **внутри** метода обьекта может быть полезным потому что они использьзуют контекст **внешней области видимости**.

```js
const obj = {
    text: "some text",
    method() {
        (() => {
            console.log(this.text)
        })()
    }
};

obj.method() // some text
```


> При попытке привязать контекст к стерлочной функции при помощи методов call, apply, bind, контекст не будет привязан.

---
### Потеря контекста:
---
Существует два варианты потери контекста:

- Потеря контекста установленного по умочланию, происходит при использовании [[1. Строгий режим|строгого режима]].
- Потеря контекста так же может произойти при изменении точки вызова метода.

```js
const obj = {
  props: "I'm a props",
  method: function(){
    console.log( this.props )
  }
}

obj.method() // I'm a props
setTimeout(obj.method, 1000) // undefined
```

```js
const obj = {
  props: "AAA",
  method: function(){
    console.log(`My props is ${this.props}`)
  }
}

obj.method() // My props is AAA
 
const func = obj.method
func() // My props is undefined
```

---
### Перепривязка контекста
----
Также контекст может быть перепривязан к другому обьекту

```js
const a = {
    name: 'A',
    say () {
        console.log('My name is', this.name);
    }
}

a.say(); // => "My name is A"

// "отвязать" функцию
const f = a.say;
f(); // => "My name is undefined"

const b = {
    name: 'B'
}

// привязать контекст
b.say = f;
b.say(); // "My name is B"
```








