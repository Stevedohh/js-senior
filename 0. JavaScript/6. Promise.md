
**Промис** - это объект используемый для отложенных и асинхронных вычислений.

**Промис** может находиться в трех состояниях:
- pending - начальное состояние, не исполнен и  не отклонен.
- fulfilled - операция завершена успешно.
- rejected - операция завершена с ошибкой.

> При создании промис находится  в состоянии (pending), а затем может стать (fulfilled), вернув полученный результат, или отклонённым (rejected), вернув причину отказа.



---
#### Статические методы `Promise`:
---

- `Promise.all(iterable)` - Ожидает исполнения всех промисов или отклонения любого из них.
> Возвращает промис, который исполнится после исполнения всех промисов в `iterable`. В случае, если любой из промисов будет отклонён, `Promise.all` будет также отклонён.

- `Promise.allSettled(iterable)` - Ожидает завершения всех полученных промисов (как исполнения так и отклонения).
> Возвращает промис, который исполняется когда все полученные промисы завершены (исполнены или отклонены), содержащий массив результатов исполнения полученных промисов.

- `Promise.race(iterable)` - Ожидает исполнения или отклонения любого из полученных промисов.
> Возвращает промис, который будет исполнен или отклонён с результатом исполнения первого исполненного или отклонённого промиса из .`iterable`.

- **Promise.reject(reason)** - Возвращает промис, отклонённый из-за `reason`.

- **Promise.resolve(value)** - Возвращает промис, исполненный с результатом `value`.

> `iterable` - массив промисов
> `reason` - причина по которйо отклонен промис
> `value` - значение с которым будет выполнен промис.



---
#### Методы экземпляра `Promise`:
---

> Важно отметить, что промисы запускаются синхронно и становятся асинхронными только внутри методов `then()` и `catch()`

- Метод `then()` возвращает промис. При его успешном выполнении `then()` вызывает функцию, которая возвращает полученное значение. В данном случае им является значение, передаваемое в обратный вызов `resolve()`.

- Метод `catch()` возвращает промис, но только в случае его отклонения. Если промис отклоняется, `catch()` вызывает функцию, которая возвращает причину возникшей ошибки.

> Так как методы `Promise.prototype.then()` и `Promise.prototype.catch()` сами возвращают промис, их можно вызывать цепочкой, создавая соединения.


```js
const promise1 = Promise.resolve(1)  
const promise2 = Promise.resolve(2)  
  
promise1.then(a => a + 10).then(console.log) // 11
  
const waitForResult = (fetch1, fetch2) => fetch1.then(res1 => fetch2.then(res2 => [res1, res2]))  // 1, 2 chain

const myPromiseAll = (promises) => {  
  return new Promise((resolve, reject) => {  
    let results = [];  
  
    promises.forEach((value, index) => {  
      Promise.resolve(value).then(result => {  
        results[index] = result;  
  
        if (results.length === promises.length) {  
          resolve(results);  
        }  
      }).catch(err => reject(err));  
    });  
  });  
}  // 1, 2 parallel
  
```
